
package org.marc4j.converter.impl;

import java.io.FileNotFoundException;

import java.io.File;

import java.io.PrintStream;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.Vector;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;

/**
 * Invoked at build time to generate a java source file (named
 * ReverseCodeTableGenerated.java) which when compiled will extend the
 * ReverseCodeTable abstract class (primarily through switch statements) and
 * which can be used by the UnicodeToAnsel converter which will produce the same
 * results as the object ReverseCodeTableHash.<br/>
 * The following routines are only used in the code generation process, and are
 * not available to be called from within an application that uses MARC4J.<br/>
 * The routines generated for converting unicode characters to MARC8 multibyte
 * characters are split into several routines to workaround a limitation in java
 * that a method can only contain 64k of code when it is compiled.
 * 
 * @author Robert Haschart
 * @author Kevin S. Clarke <ksclarke@gmail.com>
 */
public class ReverseCodeTableGenerator {

    /**
     * The main class for the reverse code table generator.
     * 
     * @param args
     * @throws FileNotFoundException
     */
    public static void main(String[] args) throws FileNotFoundException {
        Hashtable<Character, Hashtable<Integer, char[]>> charsets = null;

        try {
            SAXParserFactory factory = SAXParserFactory.newInstance();
            factory.setNamespaceAware(true);
            factory.setValidating(false);
            SAXParser saxParser = factory.newSAXParser();
            XMLReader rdr = saxParser.getXMLReader();

            InputSource src =
                    new InputSource(ReverseCodeTableHandler.class
                            .getResourceAsStream("resources/codetables.xml"));

            ReverseCodeTableHandler saxUms = new ReverseCodeTableHandler();

            rdr.setContentHandler(saxUms);
            rdr.parse(src);
            charsets = saxUms.getCharSets();
            Vector<Character> combining = saxUms.getCombiningChars();
            Object charsetsKeys[] = charsets.keySet().toArray();
            Arrays.sort(charsetsKeys);

            if (args.length > 0) {
                PrintStream outStream = new PrintStream(new File(args[0]));
                dumpTablesAsSwitchStatement(combining, charsets, outStream);
            } else {
                dumpTablesAsSwitchStatement(combining, charsets, System.out);
            }
        } catch (FileNotFoundException details) {
            throw details; // exec-maven-plugin will tell us what went wrong
        } catch (Exception details) {
            details.printStackTrace(System.out);
            System.err.println("Exception: " + details);
        }
    }

    private static void dumpTablesAsSwitchStatement(
            Vector<Character> combining,
            Hashtable<Character, Hashtable<Integer, char[]>> charsets,
            PrintStream out) {
        out.println("package org.marc4j.converter.impl;");
        out.println("");
        out.println("/**");
        out.println(" * An implementation of ReverseCodeTable that is used in converting Unicode");
        out.println(" * data to MARC8 data, that doesn't rely on any data files or resources or");
        out.println(" * data structures");
        out.println(" *");
        out.println(" * Warning: This file is generated by running the main routine in the file");
        out.println(" * ReverseCodeTableHandler.java");
        out.println(" *");
        out.println(" * Warning: Do not edit this file, or all edits will be lost at the next");
        out.println(" * build.");
        out.println(" */");
        out.println("");
        out.println("import java.util.Hashtable;");
        out.println("");
        out.println("public class ReverseCodeTableGenerated extends ReverseCodeTable {");
        out.println("");
        out.println("    /**");
        out.println("     * Returns true if supplied character is combining; else, false.");
        out.println("     *");
        out.println("     * @param c");
        out.println("     * @return True if supplied character is combining; else, false");
        out.println("     */");
        out.println("    public boolean isCombining(Character c) {");
        out.println("        switch ((int)c.charValue()) {");

        Character combineArray[] = combining.toArray(new Character[0]);
        Arrays.sort(combineArray);
        Character prevc = null;

        for (int index = 0; index < combineArray.length; index++) {
            Character c = combineArray[index];

            if (!c.equals(prevc)) {
                String hex = Integer.toHexString((int) c.charValue());
                out.println("            case 0x" + hex + ":");
            }

            prevc = c;
        }

        out.println("                return true;");
        out.println("            default:");
        out.println("                return false;");
        out.println("        }");
        out.println("    }");
        out.println("");
        out.println("    /**");
        out.println("     * Returns the character hashtable.");
        out.println("     *");
        out.println("     * @param c");
        out.println("     * @return The character hashtable");
        out.println("     */");
        out.println("    public Hashtable<Integer, char[]> getCharTable(Character c) {");
        out.println("        String resultStr1 = getCharTableCharSet(c);");
        out.println("        String resultStr2 = getCharTableCharString(c);");
        out.println("        if (resultStr2 == null) {");
        out.println("            return null;");
        out.println("        }");
        out.println("        int htSize = resultStr1.length();");
        out.println("        Hashtable<Integer, char[]> result = new Hashtable<Integer, char[]>(htSize);");
        out.println("        String res2[] = resultStr2.split(\" \");");
        out.println("        for (int index = 0; index < resultStr1.length(); index++) {");
        out.println("            Integer intChar = new Integer(resultStr1.charAt(index));");
        out.println("            result.put(intChar, deHexify(res2[(res2.length == 1) ? 0 : index]));");
        out.println("        }");
        out.println("        return result;");
        out.println("    }");
        out.println("");

        Character charsetsKeys[] = charsets.keySet().toArray(new Character[0]);
        Arrays.sort(charsetsKeys);
        StringBuilder buffer = new StringBuilder();

        out.println("    private String getCharTableCharSet(Character c) {");
        out.println("        int cVal = (int)c.charValue();");
        out.println("        switch(cVal) {");

        for (int sel = 0; sel < charsetsKeys.length; sel++) {
            Hashtable<Integer, char[]> table = charsets.get(charsetsKeys[sel]);
            Object tableKeys[] = table.keySet().toArray();
            Arrays.sort(tableKeys);
            StringBuilder sb = new StringBuilder();

            for (int index = 0; index < tableKeys.length; index++) {
                sb.append((char) ((Integer) tableKeys[index]).intValue());
            }

            String charset = sb.toString().trim();

            if (!charset.equals("1")) {
                int intChar = (int) ((Character) charsetsKeys[sel]).charValue();
                String intCharHex = Integer.toHexString(intChar);
                out.println("            case 0x" + intCharHex + ":");
                out.println("                return \"" + charset + "\";");
            }
        }
        out.println("        }");
        out.println("        return \"1\";");
        out.println("    }");
        dumpPartialCharTableCharString(out, buffer, charsetsKeys, charsets, 0,
                3500);
        dumpPartialCharTableCharString(out, buffer, charsetsKeys, charsets,
                3500, 7000);
        dumpPartialCharTableCharString(out, buffer, charsetsKeys, charsets,
                7000, 10500);
        dumpPartialCharTableCharString(out, buffer, charsetsKeys, charsets,
                10500, 14000);
        dumpPartialCharTableCharString(out, buffer, charsetsKeys, charsets,
                14000, charsetsKeys.length);

        out.println("    private String getCharTableCharString(Character c) {");
        out.println("        int cVal = (int)c.charValue();");
        out.println(buffer.toString());
        out.println("        return null;");
        out.println("    }");
        out.println("}");

    }

    static private void dumpPartialCharTableCharString(PrintStream out,
            StringBuilder buffer, Object charsetsKeys[],
            Hashtable<Character, Hashtable<Integer, char[]>> charsets,
            int startOffset, int endOffset) {
        String startByteStr =
                "0x" +
                        Integer.toHexString(((int) ((Character) charsetsKeys[startOffset])
                                .charValue()));
        String endByteStr =
                "0x" +
                        Integer.toHexString(((int) ((Character) charsetsKeys[endOffset - 1])
                                .charValue()));
        buffer.append("        if (cVal >= " + startByteStr + " && cVal <= " +
                endByteStr + ") {\n            return getCharTableCharString_" +
                startByteStr + "_" + endByteStr + "(c);\n        }\n");

        out.println("    private String getCharTableCharString_" +
                startByteStr + "_" + endByteStr + "(Character c) {");
        out.println("        switch ((int)c.charValue()) {");

        for (int sel = startOffset; sel < charsetsKeys.length &&
                sel < endOffset; sel++) {
            Hashtable<Integer, char[]> table = charsets.get(charsetsKeys[sel]);
            Object tableKeys[] = table.keySet().toArray();
            Arrays.sort(tableKeys);
            StringBuilder sb1 = new StringBuilder();
            StringBuilder sb2 = new StringBuilder();
            boolean useSB1 = false;
            char prevcharArray[] = null;

            for (int index = 0; index < tableKeys.length; index++) {
                Object value = table.get(tableKeys[index]);
                char valarray[] = (char[]) value;
                sb1.append(hexify(valarray));

                if (index == 0) {
                    sb2.append(hexify(valarray));
                }

                if (index > 0 && valarray.length == 1 &&
                        prevcharArray != null && prevcharArray.length == 1 &&
                        valarray[0] != prevcharArray[0]) {
                    useSB1 = true;
                }

                sb1.append(" ");
                prevcharArray = valarray;
            }

            String returnVal =
                    useSB1 ? sb1.toString().trim() : sb2.toString().trim();
            int intChar = (int) ((Character) charsetsKeys[sel]).charValue();
            String hex = Integer.toHexString(intChar);
            out.println("            case 0x" + hex + ":");
            out.println("                return \"" + returnVal + "\";");
        }

        out.println("            default:");
        out.println("                return null;");
        out.println("        }");
        out.println("    }");
        out.println("");
    }

    /**
     * Utility function for translating an array of characters to a two
     * character hex string of the character values.
     * 
     * @param aValArray The array of characters to encode
     * @return A string representation of the hex code
     */
    private static String hexify(char[] aValArray) {
        String result = "";

        for (int index = 0; index < aValArray.length; index++) {
            result += Integer.toHexString((int) aValArray[index]);
        }

        return result;
    }

}
